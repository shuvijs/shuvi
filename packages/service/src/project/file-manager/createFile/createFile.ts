import * as fs from 'fs';
import { reactive } from '@vue/reactivity';
import { watch } from '@shuvi/utils/lib/fileWatcher';
import { FileOptions } from '../file';

export type FileOptionsWithoutName = Omit<FileOptions, 'name'>;

export type CreateFileOption = {
  name: string;
  content: () => string | Promise<string>;
  dependencies?: string | string[];
};

export type CreateFileOptionSyncWithContext<C = any> = {
  name: string;
  content: (context: C) => string;
  dependencies?: string | string[];
};

export type CreateFileOptionSync = {
  content: () => string;
  dependencies?: string | string[];
};

/** used by file-presets because their names are dynamically generated by their paths*/

/** options without context async */
export function createFileWithoutName(
  options: Omit<CreateFileOption, 'name'>
): FileOptionsWithoutName;

/** options with context sync*/
export function createFileWithoutName<C = void>(
  options: Omit<CreateFileOptionSyncWithContext<C>, 'name'>
): FileOptionsWithoutName;

/** initializer sync*/
export function createFileWithoutName<C = void>(
  initializer: (context: C) => CreateFileOptionSync
): FileOptionsWithoutName;

export function createFileWithoutName<C = void>(options: any): any {
  return createFile<C>(options);
}

/** options without context async */
export function createFile(options: CreateFileOption): FileOptions;

/** options with context sync*/
export function createFile<C = any>(
  options: CreateFileOptionSyncWithContext<C>
): FileOptions;

/** initializer sync*/
export function createFile<C = any>(
  initializer: (context: C) => CreateFileOptionSync,
  name: string
): FileOptions;

export function createFile<C = any>(options: any, name?: string): any {
  let fileState: { content: string };
  let fileContent: string;
  let initiated = false;
  let watcher: () => void;
  let getWatcher: () => () => void;
  let currentInstance: any;
  const mounted = function (this: any) {
    watcher = getWatcher();
    currentInstance = this._;
  };
  const unmounted = () => {
    currentInstance = null;
    watcher();
  };
  if (typeof options === 'function') {
    const getContent = function (context: C) {
      const createFileOptions = options(context) as CreateFileOptionSync;
      const { dependencies = [], content } = createFileOptions;
      const files: string[] = [];
      const directories: string[] = [];
      const missing: string[] = [];
      const fileDependencies = Array.isArray(dependencies)
        ? dependencies
        : [dependencies];
      fileDependencies.forEach((filepath: string) => {
        if (fs.existsSync(filepath)) {
          if (fs.statSync(filepath).isDirectory()) {
            directories.push(filepath);
          } else {
            files.push(filepath);
          }
        } else if (filepath) {
          missing.push(filepath);
        }
      });
      if (!initiated) {
        fileState = reactive({
          content: content()
        });
        initiated = true;
      } else {
        fileState.content = content();
      }
      getWatcher = () => {
        return watch({ files, directories, missing }, () => {
          fileState.content = content();
        });
      };
      if (watcher) {
        watcher();
        watcher = getWatcher();
      }
      return fileState.content;
    };
    return {
      name,
      content: getContent,
      mounted,
      unmounted
    };
  }
  const { dependencies = [], content } = options as
    | CreateFileOption
    | CreateFileOptionSyncWithContext;
  const files: string[] = [];
  const directories: string[] = [];
  const missing: string[] = [];
  const fileDependencies = Array.isArray(dependencies)
    ? dependencies
    : [dependencies];
  if (!fileDependencies.length) {
    return options;
  }
  fileDependencies.forEach((filepath: string) => {
    if (fs.existsSync(filepath)) {
      if (fs.statSync(filepath).isDirectory()) {
        directories.push(filepath);
      } else {
        files.push(filepath);
      }
    } else if (filepath) {
      missing.push(filepath);
    }
  });
  let isPromise = false;
  getWatcher = () => {
    return watch({ files, directories, missing }, async () => {
      if (!currentInstance) return
      if (isPromise) {
        fileContent = await content(currentInstance?.ctx);
        currentInstance?.update();
      } else {
        fileState.content = content(currentInstance?.ctx) as string;
      }
    });
  };

  const getContent = (context: C) => {
    if (!initiated) {
      const contentResult = content(context);
      if (contentResult instanceof Promise) {
        isPromise = true;
        return contentResult.then(result => {
          initiated = true;
          fileContent = result;
          return fileContent;
        });
      } else {
        fileState = reactive({
          content: contentResult
        });
        initiated = true;
      }
    }
    return isPromise ? fileContent : fileState.content;
  };
  return {
    name: options.name,
    content: getContent,
    mounted,
    unmounted
  };
}
